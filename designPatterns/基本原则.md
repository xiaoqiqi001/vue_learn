## 单一职责原则
### 就一个方法或者一个类来说，应该仅有一个引起它变化的原因。
如果按照两个动机去写一个方法，那么这个方法就有两个职责，那么在需求变化的过程中，这个方法被改写的可能性就比一个职责的时候更大。最好的方式还是一个方法只做一件事情。

分离职责的时刻：
1. 如果伴随着需求的变化，函数中两个或者三个需求也跟着会相应的变化，那就不需要分离他们。
2. 如果两个职责被写在一个函数中，但是这两个需求的基本上没有变化的可能，那就不需要去分离他们。

## 最少知道原则
### 一个对象或者函数应该尽量少的与其他对象或者函数发送相互作用。

## 开放封闭原则
### 类、对象、函数应该是可以扩展的，但是不可修改的。
上面的概念在装饰者模式中应该有很强的体现，如果需要给某个函数添加功能，最好的做法是将新的功能包装在这个函数外部。

开放封闭原则是一个看起来比较虚幻的原则，并没有实际的模板教导我们怎样亦步亦趋地 实现它。但我们还是能找到一些让程序尽量遵守开放封闭原则的规律，最明显的就是找出程序 中将要发生变化的地方，然后把变化封装起来。

通过封装变化的方式，可以把系统中稳定不变的部分和容易变化的部分隔离开来。在系统的 演变过程中，我们只需要替换那些容易变化的部分，如果这些部分是已经被封装好的，那么替换 起来也相对容易。而变化部分之外的就是稳定的部分。在系统的演变过程中，稳定的部分是不需 要改变的。

可以使用回调函数来代表当前函数中容易变化的部分，当前函数会因为回调函数的不同，执行的结果也会不同

对于不能完全做到开放封闭原则的程序，可以采用两种方法来做：
1. 挑选中最容易发生变化的地方，然后对这些变化进行封装。
2. 在不可避免要发生修改的地方，尽量修改那些相对容易修改的地方，比如一些开源库提供的配置文件，修改配置文件就比修改开源库代码容易很多。

开发方法：某个项目开始开发的时候，其实并不知道哪里变化，哪里不会发生变化，在开发的过程中，可以先默认所有都是不变的，当某块发生变化了，再对其进行封装。